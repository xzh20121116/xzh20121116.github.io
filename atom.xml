<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xzh20121116.github.io</id>
    <title>温故知新</title>
    <updated>2020-04-22T01:59:59.952Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xzh20121116.github.io"/>
    <link rel="self" href="https://xzh20121116.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://xzh20121116.github.io/images/avatar.png</logo>
    <icon>https://xzh20121116.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 温故知新</rights>
    <entry>
        <title type="html"><![CDATA[mysql之锁]]></title>
        <id>https://xzh20121116.github.io/post/mysql-zhi-suo/</id>
        <link href="https://xzh20121116.github.io/post/mysql-zhi-suo/">
        </link>
        <updated>2020-04-21T13:53:28.000Z</updated>
        <content type="html"><![CDATA[<p>mysql之锁</p>
<p>mysql 里面<strong>表级别</strong>的锁有两种：表锁、元数据锁（meta data lock ，MDL）</p>
<p><strong>表锁</strong></p>
<blockquote>
<p>表锁的语法是 lock tables ... read/write。与 FTWRL类似，可以用 <strong>unlock tables</strong>主动释放锁，也可以在客户端断开连接的时候自动释放。需要注意：lock tables 语法除了会限制其他的线程的读写之外，也限定了本线程接下来的操作对象</p>
<p><strong>举个例子</strong>：</p>
<p>线程A中执行 lock tables  t1 read，t2 write  这个语句，则其他线程写 t1 ，读t2 的语句都会被阻塞。线程A 在释放锁之前，也只能 执行读 t1、写t2的操作。连写t1都不允许，自然也不能访问其他表</p>
<p>对于innodb来说，一般不使用lock tables命令，影响太大</p>
</blockquote>
<p>MDL</p>
<blockquote>
<p>mdl不需要显式使用，在访问一个表的时候会自动加上。</p>
<p><strong>mdl的作用</strong>：保证读写的正确性</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试准备]]></title>
        <id>https://xzh20121116.github.io/post/we/</id>
        <link href="https://xzh20121116.github.io/post/we/">
        </link>
        <updated>2020-04-21T04:34:37.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200421213015.png" alt="image-20200416102643022" loading="lazy"></figure>
<h1 id="全部使用长连接可能会导致mysql占用内存涨得特别快">全部使用长连接，可能会导致mysql占用内存涨得特别快？</h1>
<p>因为mysql在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，如果长连接累计下来，导致内存占用太大，被系统强行杀掉（oom），从现象看就是mysql异常重启了</p>
<h1 id="如何解决呢">如何解决呢？</h1>
<p>两种方案：</p>
<ol>
<li>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h1 id="redo-log重做日志是innodb特有的日志">redo log（重做日志：是innodb特有的日志）</h1>
<p><strong>特点：</strong> <strong>记录的是数据修改之后的值，不管事务是否提交都会记录下来</strong></p>
<p>用于保证crash-safe（防撞）能力，</p>
<ul>
<li>innodb_flush_log_at_trx_commit参数设置成1，表示每次事务的redo log 都直接持久化到磁盘，建议设置成1，保证重启后数据不丢失</li>
<li>sync_binlog 设置为1，表示每次事务的binlog都持久化到磁盘，保证重启后binlog不丢失</li>
</ul>
<p>WAL技术，全称 WRITE-AHEAD logging</p>
<p>它的关键点就是先写日志，再写磁盘</p>
<p>当有一条记录要更新的时候，innodb引擎就会先把记录写到 redolog，并更新内存，这个时候更新就算完成了。</p>
<p>InnoDb会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打样以后掌柜做的事</p>
<p>有了redolog，innodb就可以保证技术数据库发生异常重启，之前提交的记录都不会丢失，这就是crash-safe</p>
<h1 id="bin-log归档日志server层自己的日志所有引擎都可以使用">bin log（归档日志：server层自己的日志，所有引擎都可以使用</h1>
<p>binlog有两种模式</p>
<ul>
<li>statement格式记录的是sql语句</li>
<li>row格式（一般采用这个）：记录行的内容，记录两行，更新前，更新后都有</li>
</ul>
<h2 id="redolog与binglog区别">redolog与binglog区别</h2>
<ol>
<li>redolog是innodb引擎特有的，只能innodb用；</li>
<li>binlog是mysql的server层实现的，所有引擎都可以用</li>
<li>redolog 是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”</li>
<li>binlog是逻辑日志，记录的是“<strong>语句的原始逻辑：给id = 2 的这一行的c字段加1</strong>”</li>
<li>redoglog是循环写的，空间固定会用完，binlog是可以追加下入的，当binlog文件写到一定大小的时候，会自动切换下一个，并不会覆盖以前的日志</li>
</ol>
<h1 id="备份恢复">备份恢复</h1>
<p>以binlog为基础，通过它记录的完整逻辑操作，备份出一个和源库一样的数据</p>
<h1 id="事务">事务</h1>
<h2 id="事务的特性">事务的特性：</h2>
<p>原子性、一致性、隔离性、持久性</p>
<h2 id="多事务同事执行的时候可能会出现的问题">多事务同事执行的时候，可能会出现的问题：</h2>
<ul>
<li>
<p>脏读()</p>
<blockquote>
<p>当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，<br>
另一个事务B 来读取了修改后的内容并且使用了，<br>
之后事务A提交了，此时就引起了脏读。</p>
<p>此情况仅会发生在： <strong>读未提交</strong>.</p>
</blockquote>
</li>
<li>
<p>不可重复读</p>
<blockquote>
<p>在一个事务A中多次操作数据，在事务操作过程中(未最终提交)，<br>
事务B也才做了处理，并且该值发生了改变，这时候就会导致A在事务操作<br>
的时候，发现数据与第一次不一样了。 就是不可重复读。</p>
<p>此情况仅会发生在：<strong>读未提交、读已提交</strong></p>
</blockquote>
</li>
<li>
<p>幻读</p>
<blockquote>
<p>一个事务按相同的查询条件重新读取以前检索过的数据，<br>
却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。</p>
<p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.<br>
一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</p>
<p>此情况会回发生在：<strong>读未提交、读提交、可重复读</strong>的隔离级别.</p>
</blockquote>
</li>
</ul>
<h2 id="事务的隔离级别">事务的隔离级别</h2>
<ul>
<li>
<p>读未提交（脏读、不可重复读、幻读）</p>
<blockquote>
<p>一个事务还未提交，它所做的变更就可以被别的事务看到</p>
</blockquote>
</li>
<li>
<p>读已提交（不可重复读、幻读）</p>
<blockquote>
<p>一个事务提交之后，它所做的变更才可以被别的事务看到</p>
</blockquote>
</li>
<li>
<p>可重复读（mysql默认、幻读）</p>
<blockquote>
<p>一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的</p>
</blockquote>
</li>
<li>
<p>串行化</p>
<blockquote>
<p>对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</p>
</blockquote>
</li>
</ul>
<h2 id="创建视图的时机">创建视图的时机</h2>
<p>实际上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准</p>
<p><strong>可重复读</strong>：在事务启动时创建视图，整个事务存在其都用这个视图</p>
<p>**读已提交：**这个视图是sql语句开始执行的时候创建的</p>
<p>**读未提交：**没有视图的概念，直接返回记录上的最新值</p>
<p><strong>串行化</strong>：直接加锁的方式来避免并行访问</p>
<h2 id="什么是视图">什么是视图</h2>
<ul>
<li>view，用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果，创建视图的语法是 create view，查询方法与表一样</li>
<li>InnoDB在实现<strong>MVCC</strong>时用到的一致性读视图，即： <strong>consistent read view</strong>，用以支持 读已提交、可重复读 的实现</li>
</ul>
<h2 id="mvcc的实现逻辑">mvcc的实现逻辑</h2>
<p>不同时刻启动的事务会有不同的 read-view，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制</p>
<blockquote>
<p>一个值被按顺序 从 1 修改为 2、3、4，对于read-view a，要得到1，就必须将当前值依次执行图中的所有回滚操作得到</p>
<figure data-type="image" tabindex="2"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200421213037.png" alt="image-20200416165224236" loading="lazy"></figure>
</blockquote>
<h2 id="快照在mvcc里是怎么工作的">快照在mvcc里是怎么工作的</h2>
<p>对于<strong>可重复读</strong>：事务启动的时候就“<strong>拍了个快照</strong>”，注意，这个快照是基于整库的。</p>
<p>这个时候，你可能会说了，如果一个库100g，那么我起一个事务，mysql就要拷贝100g啊</p>
<p>实际上，并不需要拷贝这100g</p>
<p>InnoDB里面每个事务都有一个唯一事务id，叫 transaction id，它是事务开始的时候向InnoDb的事务系统申请的， 按申请顺序递增的。</p>
<p>而每行的数据都是有多个版本的，每次事务更新数据的时候，都会生成一个新的数据版本，并且把 事务id 赋值给这个数据版本的事务id，记为 row trx_id，旧的数据版本也要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，可能有多个版本，每个版本都有自己的row_trx_id。</p>
<p>语句更新会生成 <strong>undo log 回滚日志</strong>，每个版本并不是物理上真实存在的，而是当需要的时候根据当前版本和 undo log 计算出来的</p>
<p>按照 <strong>可重复读的定义</strong>一个事务启动的时候，能够看到所有已经提交的事务，但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>在实现上，InnoDb为每个事务构造了一个数组，用来保存这个事务启动瞬间，当时正在“<strong>活跃</strong>”的所有事务id，活跃是指，启动了但是没有提交</p>
<p>数组里面事务id的最小值为低水位，当前系统里面已经创建国的事务id的最大值+1为高水位</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图 read-view</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的</p>
<h2 id="配置隔离界别的方法">配置隔离界别的方法</h2>
<p>启动参数transaction-isolation</p>
<h2 id="事务隔离的实现">事务隔离的实现</h2>
<p>每条记录在更新的时候都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本， 这就是数据库的多版本并发控制（<strong>MVCC</strong>）</p>
<h2 id="回滚日志什么时候删除">回滚日志什么时候删除？</h2>
<p>系统判断没有事务需要用到这些回滚日志的时候，回滚日志就会被删除</p>
<h2 id="什么时候不需要了">什么时候不需要了？</h2>
<p>当系统里没有比这个回滚日志更早的read-view的时候</p>
<h2 id="为什么不使用长事务">为什么不使用长事务</h2>
<p>长事务意味着系统里存在很多很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间</p>
<p>长事务占用锁资源，可能会拖垮库</p>
<h2 id="如何避免长事务对业务的影响">如何避免长事务对业务的影响</h2>
<ul>
<li>开发时，尽量减小事务范围</li>
<li>如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长，监控<strong>Inndb_trx表（查询事务时间）</strong>，发现长事务报警</li>
</ul>
<p><strong>首先，从应用开发端来看</strong>：</p>
<ol>
<li>确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。</li>
<li>确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。</li>
<li>业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）</li>
</ol>
<p><strong>其次，从数据库端来看：</strong></p>
<ol>
<li>监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；</li>
<li>Percona 的 pt-kill 这个工具不错，推荐使用；</li>
<li>在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；</li>
<li>如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。</li>
</ol>
<h1 id="索引">索引</h1>
<h2 id="主键索引查询">主键索引查询</h2>
<p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p>
<h2 id="普通索引查询">普通索引查询</h2>
<p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</p>
<p>也就是说非主键索引的查询需要多扫描一棵索引树，因此应尽量使用主键查询</p>
<h2 id="什么是回表">什么是回表</h2>
<p>通过普通索引无法一次获取到查询结果，需要根据普通索引找到的主键索引，再从主键索引获取所需数据的过程叫回表</p>
<h2 id="索引维护">索引维护</h2>
<p>使用自增主键的插入，符合递增插入，每次插入都是一条新纪录，都是追加操作，不涉及挪动其他记录，也不会触发叶子节点的分裂</p>
<p><strong>从存储空间考虑</strong></p>
<blockquote>
<p>比如说有一个身份证，还有一个自增id，用哪个做主键呢？</p>
<p>由于每个非主键索引的叶子节点存储都是主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，如果用整型做主键，则只需要4个字节，如果是长整型（bigint）则是8个字节</p>
</blockquote>
<p>显然：<strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</strong></p>
<h2 id="为什么使用b树做索引">为什么使用b+树做索引</h2>
<p>能够很好的配合磁盘读写的特性，减少单词查询的磁盘访问次</p>
<h2 id="最左前缀">最左前缀</h2>
<p>联合索引（a,b）, 一般不需要单例的在a上建立索引了</p>
<ul>
<li>如果可以通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
</ul>
<p>比如（身份证号，姓名）这个高频请求建立联合索引</p>
<p><strong>如果查询条件里只有 b 字段是无法使用(a,b)这个联合索引的</strong></p>
<p>此时是否需要维护额外的b索引呢？这个时候需要考虑空间了</p>
<blockquote>
<p>比如说（name，age‘），name 字段比age字段大，name建议建立一个（name，age的联合索引和一个age的单独索引）</p>
</blockquote>
<h2 id="索引下推">索引下推</h2>
<pre><code class="language-sql">select * from tuser where name like '张%' and age=10 and ismale=1;
</code></pre>
<p>查找出名字的第一个字“张”，且年龄是10岁的所有男孩</p>
<p>根据(name,age)索引，开始查找</p>
<ul>
<li>在mysql5.6之前，只能从id3开始一个个回表，到主键索引上找出数据行，在对比字段值</li>
<li>5.6版本引入了 <strong>索引下推优化</strong>，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200421213058.png" alt="image-20200416135213919" loading="lazy"></figure>
<p>上面是无索引下推执行流程</p>
<blockquote>
<p>每一个虚线箭头表示回表一次。</p>
<p>在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p>
</blockquote>
<figure data-type="image" tabindex="4"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200421213108.png" alt="image-20200416135243161" loading="lazy"></figure>
<p>上面索引下推执行流程</p>
<blockquote>
<p>InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
</blockquote>
<h1 id="锁">锁</h1>
<p>mysql里面的锁根据加锁范围分为三类：全局锁、表级锁、行锁</p>
<h2 id="全局锁">全局锁</h2>
<ul>
<li>
<p>使用场景：做全局逻辑备份，也就是把整库每个表都select出来存成文本</p>
<blockquote>
<p>MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (<strong>FTWRL</strong>)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
</blockquote>
<p><strong>缺点</strong></p>
</li>
<li>
<p>如果在主库上备份，那么备份期间都不能执行更新，业务基本停摆</p>
</li>
<li>
<p>从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟</p>
</li>
</ul>
<p>不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的</p>
<ul>
<li>
<p><strong>如何获得一致性视图</strong></p>
<blockquote>
<p>在可重复读的隔离界别下开启一个事务</p>
<p>官方自带的逻辑备份工具是mysqldump，使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于mvcc的支持，这个过程中数据是可以正常更新的</p>
</blockquote>
</li>
<li>
<p>对于全部是innodb引擎的库，建议使用<strong>single-transaction</strong>参数</p>
</li>
<li>
<p>问题来了，有了这个功能，为什么还需要FTWRL（全局只读）呢？</p>
<blockquote>
<p>因为：有的引擎是不支持这个隔离界别的，比如<strong>mylsam</strong>不支持事务的引擎，如果备份过程中有更新，总是能取到最新的数据，那么就破坏了数据一致性，这个时候就用到<strong>FTWRL</strong></p>
</blockquote>
</li>
<li>
<p>既然全库只读，为什么不使用 set global readOnly=true 的方式呢？</p>
<blockquote>
<p>这个方式也可以放全库进入只读状态，但是还是建议使用FTWRL</p>
<ol>
<li>有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库，因此，修改global变量的方式影响面更大，不建议使用</li>
<li>异常处理机制上的差距，执行<strong>FTWRL</strong>命令之后，客户端发生异常断开，那么mysql会自动释放这个全局锁</li>
<li>而设置成readonly之后，如果客户端发生异常，则数据库一致保持readonly状态，风险高</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="表锁">表锁</h2>
<p>mysql中的表锁有两种，一种是元数据锁（meta data lock，mdl），一种是表锁</p>
<ul>
<li><strong>表锁的语法是 lock tables … read/write。</strong></li>
</ul>
<blockquote>
<p>与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>
<p>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>
</blockquote>
<ul>
<li>另一类表级的锁是 <strong>MDL（metadata lock)。</strong></li>
</ul>
<blockquote>
<p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
<p>在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
</blockquote>
<p>所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。</p>
<p>事务中mdl锁，在语句执行开始时申请，但是语句结束后并不会立马释放，而是等整个事务提交后再释放</p>
<h2 id="如何安全的给小表加字段">如何安全的给小表加字段</h2>
<ul>
<li>首先处理长事务，因为事务不提交，就会一直占用mdl锁，先查询出长事务，暂停执行变更操作，或者kill掉长事务，但是如果是热点表，请求很频繁呢，kill就不管用了</li>
<li>在alter table语句里面设定等待时间，如果在指定的等待时间里面能够拿到mdl写锁最好，拿不到也不要阻塞后面的业务语句，之后由dba重试命令来执行</li>
</ul>
<h2 id="两阶段锁协议">两阶段锁协议</h2>
<p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这就是两阶段锁协议</p>
<blockquote>
<p>知道了这个设定，的帮助是：如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放</p>
</blockquote>
<h2 id="死锁">死锁</h2>
<p><strong>原始的两种策略</strong></p>
<ul>
<li>直接进入等待，直到超时，超时的时间可以通过参数 <strong>innodb_lock_wait_timeout</strong>来设置，默认是50s</li>
<li>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行，将 <strong>innodb_deadlock_detect</strong> 设置为 on，表示开启这个逻辑</li>
</ul>
<p>正常情况推荐使用第二种策略，即：主动死锁检测；</p>
<p><strong>但是</strong>如果有1000个并发线程要同事更新一行，那么死锁检测操作就是100万这个量级了，虽然最终检测的结果是没有死锁，但是这期间要消耗大量的cpu资源，<strong>结果</strong>：cpu利用率很高，但是每秒却执行不了几个事务</p>
<p><strong>真实的两种策略</strong></p>
<ol>
<li>可以死锁检测临时关掉，危险：意味着出现大量的超时</li>
<li>控制并发度：基本思路：对于相同行的更新，在进入引擎前排队 ，这样innodb内部就不会有大量的死锁检测工作了</li>
</ol>
<h2 id="删除表里面的前10000行数据选择哪一种">删除表里面的前10000行数据，选择哪一种</h2>
<ol>
<li>
<p>直接 delete from t limit 10000;</p>
<blockquote>
<p>单个语句占用时间长，锁的时间比较长，大事务会导致主从延迟</p>
</blockquote>
</li>
<li>
<p>在一个连接内循环执行20次 delete from t limit 500；</p>
<blockquote>
<p>相对较好</p>
</blockquote>
</li>
<li>
<p>在20 个连接中同时执行delete from t limit 500；</p>
<blockquote>
<p>会人为造成锁冲突</p>
</blockquote>
</li>
</ol>
<p>要区分行锁、mdl锁、表锁的区别，对于InnoDb更新一行，可能过了mdl关，却被挡在行锁阶段</p>
<h1 id="索引-2">索引</h1>
<h2 id="普通索引-唯一索引-如何选择">普通索引  、 唯一索引 ，如何选择？</h2>
<p>查询性能上是没太大区别的，主要考虑的是<strong>更新性能</strong>的影响，尽量使用普通索引</p>
<p><strong>普通索引</strong>：会将变更操作缓存到changbuffer中，在下一次读的时候才会进行一个merge操作，更新磁盘中</p>
<ul>
<li>日志系统，账单系统，写多读少</li>
</ul>
<p>如果使用的是机械硬盘，change buffer这个机器的效果是非常显著的，</p>
<h2 id="change-buffer-与-redo-log">change buffer 与 redo log</h2>
<p><strong>redo log</strong>：先写日志，再写磁盘，也是尽量减少随机读写</p>
<blockquote>
<p>举个例子，要往 一个表里插入两条书库，k1，k2；</p>
<pre><code class="language-sql">insert into t(id,k) values(id1,k1),(id2,k2);
</code></pre>
<p>k1所在的数据页（page1）在内存（innodb buffer pool ）中，k2所在的数据页（page2）不在内存中</p>
<ol>
<li>page1在内存中，直接更新内存</li>
<li>page2不在内存中，往 内存的change buffer 区域，记录一条：“我要往page2 插入一行 ”的信息</li>
<li>将1、2两个动作记入到 redo log 中</li>
</ol>
<p>至此，事务就完成， 执行这两个更新的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作盒合在一起写了一次磁盘）</p>
<p>现在执行读操作</p>
<pre><code class="language-sql">select * from t where k in (k1, k2)
</code></pre>
<ol>
<li>
<p>读page1的时候，直接从内存返回。（此时还没有写磁盘，wal之后如果读数据，不一定读盘）</p>
</li>
<li>
<p>读page2的时候，需要把page2从磁盘读入内存中，然后应用change buffer里的操作日志，生成一个正确的版本并返回结果</p>
<p>可以看到，读page2的时候，这个数据页才会被读入内存</p>
</li>
</ol>
</blockquote>
<p>简单的对比这个两个机制：</p>
<ul>
<li>redolog：主要节省的是随机写磁盘的 io消耗（转成顺序写）</li>
<li>change buffer：主要节省的则是随机读磁盘的 io消耗</li>
</ul>
<h2 id="mysql为什么会选错索引">mysql为什么会选错索引？</h2>
<p>选择索引是优化器的逻辑</p>
<p>扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的cpu资源越少</p>
<p>当然扫描行并不是唯一的判断标准，优化器还会结合是否使用临时表，是否排序等因素进行综合判断</p>
<p>有时候回表也肯能导致盘算执行行数出错</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://xzh20121116.github.io/post/hello-gridea/</id>
        <link href="https://xzh20121116.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>