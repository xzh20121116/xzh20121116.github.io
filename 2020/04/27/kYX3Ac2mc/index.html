<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HashMap底层、1.7与1.8区别、常见面试题 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="谈谈hashMap的底层数据结构实现，以及JDK1.8后做了哪些改进、以及常见的面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap底层、1.7与1.8区别、常见面试题">
<meta property="og:url" content="http://yoursite.com/2020/04/27/kYX3Ac2mc/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="谈谈hashMap的底层数据结构实现，以及JDK1.8后做了哪些改进、以及常见的面试题">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427113334.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427115545.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427105750.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427132313.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427105258.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427152811.png">
<meta property="og:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427152956.png">
<meta property="article:published_time" content="2020-04-27T05:11:29.000Z">
<meta property="article:modified_time" content="2020-04-28T08:37:21.319Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427113334.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-kYX3Ac2mc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/kYX3Ac2mc/" class="article-date">
  <time datetime="2020-04-27T05:11:29.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HashMap底层、1.7与1.8区别、常见面试题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>谈谈hashMap的底层数据结构实现，以及JDK1.8后做了哪些改进、以及常见的面试题</p>
<a id="more"></a>

<h1 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h1><p><strong>1.7</strong></p>
<blockquote>
<ul>
<li><p>数组+链表</p>
</li>
<li><p><code>Entry</code>节点是他的内部类，实现了<code>Map.ENTRY()</code></p>
</li>
<li><p>插入过程使用<code>头插法</code>：扩容时死循环</p>
</li>
</ul>
</blockquote>
<p>1.8</p>
<blockquote>
<ul>
<li>数组+链表+红黑树</li>
<li><code>Node</code>节点是他的内部类，实现了<code>Map.ENTRY()</code></li>
<li>使用<code>尾插法</code>：避免扩容时死循环</li>
</ul>
</blockquote>
<h1 id="二、底层实现"><a href="#二、底层实现" class="headerlink" title="二、底层实现"></a>二、底层实现</h1><p>从三个方面说：<code>put()</code>、 <code>get()</code>、 <code>resize()</code>，对比1.7版本与1.8版本。</p>
<h2 id="2-1-jdk7-版本"><a href="#2-1-jdk7-版本" class="headerlink" title="2.1    jdk7 版本"></a>2.1    jdk7 版本</h2><h3 id="2-1-1-put"><a href="#2-1-1-put" class="headerlink" title="2.1.1    put()"></a>2.1.1    put()</h3><blockquote>
<p>是有返回值的，</p>
<p>如果是key已存在，覆盖旧值，则返回旧值</p>
<p>如果新key不存在，则返回null</p>
</blockquote>
<p><strong>源码</strong></p>
<blockquote>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427113334.png" alt="image-20200427113334153" style="zoom:50%;" />
</blockquote>
<p>如图所示，整个<code>**流程**</code>可以大致分为四步处理</p>
<blockquote>
<ol>
<li>key为null的处理</li>
<li>计算目标bucket的下标：即数组中的位置</li>
<li>找到指定bucket，遍历Entry节点链表，若找到相同key相同的Entry节点，则做替换</li>
<li>未没有找到目标Entry节点时，则新增一个Entry节点</li>
</ol>
</blockquote>
<p><code>putForNllKey（value）</code>：key为null的处理说明</p>
<blockquote>
<p>说明1：HashMap中，可以存在null的kv</p>
<p>说明2：key为null的，固定是放在table[0]的位置：即下标为0的bucket</p>
<ul>
<li>首先选择<strong>table[0]</strong>位置的链表</li>
<li>对链表做遍历操作</li>
<li>如果有节点的key为null，则将新value替换掉旧value</li>
<li>如果没有key为null的节点，则新增一个key为null的Entry节点</li>
</ul>
</blockquote>
<p><code>void addEntry(int hash, K key, V value, int bucketIndex)</code></p>
<blockquote>
<p>这是一个通用方法</p>
<p>给定四个参数，新增一个Entry节点，另外还担负了扩容职责。</p>
<p>如果哈希表中存放的<strong>kv数量</strong>超过了当前<strong>阈值threshold</strong>，且当前的bucket下标有链表存在，那么就进行<strong>扩容resize</strong>处理</p>
<p>扩容后，<strong>重新计算hash</strong>，得到新的bucket下标，然后使用<strong>头插法</strong>新增节点</p>
</blockquote>
<h3 id="2-1-2-resize"><a href="#2-1-2-resize" class="headerlink" title="2.1.2    resize()"></a>2.1.2    resize()</h3><p><strong>流程</strong></p>
<blockquote>
<ol>
<li><p>插入kv时，发现容量不足</p>
</li>
<li><p>保存旧的数组（old table）</p>
</li>
<li><p>根据新容量（2倍）新建数组（new table）</p>
</li>
<li><p>将old table上的kv 转移到 new table 中</p>
<blockquote>
<ol>
<li>遍历旧数组的每个数据</li>
<li>重新计算每个<code>旧kv</code>在新数组的位置（<code>不含新kv</code>）</li>
<li>将旧数组上的每个<code>旧kv</code>,逐个转移到新数组中（头插法，<code>不含新kv</code>）</li>
</ol>
</blockquote>
</li>
<li><p>新数组引用到HashMap的table属性上</p>
</li>
<li><p>重新设置扩容阈值（threshold）</p>
</li>
<li><p>扩容结束</p>
<blockquote>
<p>此时table = 扩容后（2倍）+ 旧数据</p>
</blockquote>
</li>
<li><p>处理第一步要插入的kv</p>
<blockquote>
<ol>
<li>计算新kv的hash值</li>
<li>计算出新kv在table中的位置</li>
<li>将数据插入到对应的位置</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<p><strong>源码</strong></p>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427115545.png" alt="image-20200427115545105" style="zoom:50%;" />

<p><strong>核心点1</strong>：扩容后大小是扩容前的<strong>2倍</strong></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oldCapacity = table.length;</span><br><span class="line">newCapacity = <span class="number">2</span> * oldCapacity;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>核心点2</strong>：<strong>数据搬迁</strong>：从旧table（即数组）迁到扩容后的新table</p>
<blockquote>
<ol>
<li><p>先决策是否需要对每个Entry链表节点重新hash</p>
</li>
<li><p>然后根据hash值计算得到bucket下标</p>
</li>
<li><p>使用头插法做接点迁移</p>
</li>
</ol>
</blockquote>
<p><strong>核心点3</strong></p>
<blockquote>
</blockquote>
<h3 id="2-1-3-get"><a href="#2-1-3-get" class="headerlink" title="2.1.3    get()"></a>2.1.3    get()</h3><p>相对于put（）方法，get（）方法的实现就简单多了，主要分为两步</p>
<ol>
<li>通过key的hash值计算出在table中的下标</li>
<li>遍历对应table的链表，逐个对比，得到结果。</li>
</ol>
<h3 id="2-1-4-fail-fast策略"><a href="#2-1-4-fail-fast策略" class="headerlink" title="2.1.4    fail-fast策略"></a>2.1.4    fail-fast策略</h3><p>hashmap中有一个变量<code>modcount</code>，用于实现Hashmap中的快速失败</p>
<p>在对Map的做迭代(Iterator)操作时，会将<strong><code>modCount</code></strong>域变量赋值给<strong><code>expectedModCount</code></strong>局部变量。</p>
<p>在迭代过程中，用于做内容修改次数的一致性校验。</p>
<p>如果两个对比不一致，则会抛出异常<strong><code>ConcurrentModificationException</code></strong></p>
<h2 id="2-2-jdk8-版本"><a href="#2-2-jdk8-版本" class="headerlink" title="2.2    jdk8 版本"></a>2.2    jdk8 版本</h2><h3 id="2-2-0-与jdk1-7的核心差异"><a href="#2-2-0-与jdk1-7的核心差异" class="headerlink" title="2.2.0    与jdk1.7的核心差异"></a>2.2.0    与jdk1.7的核心差异</h3><ol>
<li><p>数据结构不同，1.8为数组+链表+红黑树</p>
</li>
<li><p>resize时数据迁移的方式不同，1.8为尾插法</p>
</li>
<li><p>链表节点的定义不同（内核没有变，不影响理解）：Entry–&gt;Node类，都实现了Map.Entry()</p>
</li>
</ol>
<h3 id="2-2-1-put"><a href="#2-2-1-put" class="headerlink" title="2.2.1    put()"></a>2.2.1    put()</h3><p>与1.7类似，多了转换红黑树的步骤，头插法变尾插法，其他与1.7类似</p>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427105750.png" alt="image-20200427105750336" style="zoom:50%;" />

<p><strong>源码</strong></p>
<blockquote>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427132313.png" alt="image-20200427132313825" style="zoom:50%;" />
</blockquote>
<h3 id="2-2-2-resize"><a href="#2-2-2-resize" class="headerlink" title="2.2.2    resize()"></a>2.2.2    resize()</h3><p><strong>流程</strong></p>
<blockquote>
<ol>
<li><p>插入新kv，发现容量不足</p>
</li>
<li><p>异常情况判断</p>
<blockquote>
<ol>
<li>是否需要初始化</li>
<li>若当前容量  &gt; 最大值，则不扩容</li>
</ol>
</blockquote>
</li>
<li><p>根据新容量（2倍）新建数组（new table）</p>
</li>
<li><p>保存旧数组(old table)</p>
</li>
<li><p>将旧数组上的数据转移到新数组中（old table -&gt; new table）</p>
<blockquote>
<ol>
<li><p>遍历数组的每个数据</p>
</li>
<li><p>重新计算每个数据在新数组中的存储位置（<code>含新数据</code>）</p>
<blockquote>
<ul>
<li>原位置  or  原位置+旧容量</li>
</ul>
</blockquote>
</li>
<li><p>将旧数组上的每个主句逐个转移到新数组中（<code>含新数据</code>）</p>
<blockquote>
<p>尾插法</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>将新数组table引用到HashMap的table属性上</p>
</li>
<li><p>重新设置扩容阈值（threshold）</p>
</li>
<li><p>扩容结束</p>
</li>
</ol>
</blockquote>
<h3 id="2-2-3-get"><a href="#2-2-3-get" class="headerlink" title="2.2.3    get()"></a>2.2.3    get()</h3><p>比较简单</p>
<ol>
<li>根据key计算出hash值，进一步计算得到table的下标，若bucket上为红黑树，则再进行红黑树查找，若不是红黑树，遍历链表</li>
</ol>
<p>map家族的关系</p>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427105258.png" alt="image-20200427105258224" style="zoom:50%;" />

<h1 id="三、HashMap、HashTable对比"><a href="#三、HashMap、HashTable对比" class="headerlink" title="三、HashMap、HashTable对比"></a>三、HashMap、HashTable对比</h1><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1    共同点"></a>3.1    共同点</h2><p>底层都是使用哈希表+链表的实现方式</p>
<h2 id="3-1-不同点"><a href="#3-1-不同点" class="headerlink" title="3.1    不同点"></a>3.1    不同点</h2><ul>
<li><p>Hashtable线程安全，所有的操作都添加了Synchronized关键字修饰，效率低下</p>
</li>
<li><p>很少使用hashtable了，太旧了</p>
</li>
<li><p>HashTable  的 kv 都不能为null，否则直接npe</p>
</li>
</ul>
<h1 id="四、HashMap线程不安全的原因"><a href="#四、HashMap线程不安全的原因" class="headerlink" title="四、HashMap线程不安全的原因"></a>四、HashMap线程不安全的原因</h1><h2 id="4-1-数据覆盖问题"><a href="#4-1-数据覆盖问题" class="headerlink" title="4.1    数据覆盖问题"></a>4.1    数据覆盖问题</h2><p>情景描述：</p>
<blockquote>
<p>两个线程执行<code>put（）</code>操作时，可能导致数据覆盖，1.7、1.8都存在此问题</p>
<p>a、b两个线程同时执行put操作，且两个key都指向同一个bucket，那么此时两个结点都会做头插法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看下最后的<code>createEntry()</code>方法，首先获取到了bucket上的头结点，然后再将新结点作为bucket的头部，并指向旧的头结点，完成一次头插法的操作。<br> 当线程A和线程B都获取到了bucket的头结点后，若此时线程A的时间片用完，线程B将其新数据完成了头插法操作，此时轮到线程A操作，但这时线程A所据有的旧头结点已经过时了（并未包含线程B刚插入的新结点），线程A再做头插法操作，就会抹掉B刚刚新增的结点，导致数据丢失。</p>
<p>其实不光是<code>put()</code>操作，删除操作、修改操作，同样都会有覆盖问题。</p>
</blockquote>
<h2 id="4-2-扩容时导致死循环"><a href="#4-2-扩容时导致死循环" class="headerlink" title="4.2    扩容时导致死循环"></a>4.2    扩容时导致死循环</h2><p>1.7多线程会出现，因为扩容使用头插法，将原本的顺序做了翻转</p>
<p>1.8就没有了，因为用了尾插法。</p>
<h1 id="五、如何规避HashMap的线程不安全"><a href="#五、如何规避HashMap的线程不安全" class="headerlink" title="五、如何规避HashMap的线程不安全"></a>五、如何规避HashMap的线程不安全</h1><h2 id="5-1-将Map转为包装类"><a href="#5-1-将Map转为包装类" class="headerlink" title="5.1    将Map转为包装类"></a>5.1    将Map转为包装类</h2><p><strong><code>Collections.SynchronizedMap()</code></strong>方法，实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; testMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">...</span><br><span class="line"> <span class="comment">// 转为线程安全的map</span></span><br><span class="line">Map&lt;String, Integer&gt; map = Collections.synchronizedMap(testMap);</span><br></pre></td></tr></table></figure>

<p>内部实现很简单，等同于Hashtable，只是对当前传入的map对象，新增对象锁（synchronized）</p>
<h2 id="5-2-使用ConcurrentHashMap"><a href="#5-2-使用ConcurrentHashMap" class="headerlink" title="5.2    使用ConcurrentHashMap"></a>5.2    使用ConcurrentHashMap</h2><h1 id="六、链表转红黑树的阈值是8，而不是7或者20？"><a href="#六、链表转红黑树的阈值是8，而不是7或者20？" class="headerlink" title="六、链表转红黑树的阈值是8，而不是7或者20？"></a>六、链表转红黑树的阈值是8，而不是7或者20？</h1><p>由于treenode（红黑树节点）的大小约是常规节点(HashMap的node节点？)的两倍，</p>
<p>因此我们仅在容器包含足够的节点以保证使用时，才才使用他们</p>
<blockquote>
<p>这句话是什么意思呢？就是因为红黑树节点占用空间，不到万不得已不用他</p>
</blockquote>
<p>当他们（红黑树）变得太小（由于移除或调整大小）时，会转换成普通节点</p>
<blockquote>
<p>如果红黑树&lt;=6退化成链表</p>
<p>如果链表长度&gt;=8转变为红黑树</p>
<p>中间有个<code>差值7</code>可以有效防止链表和树的频繁转换</p>
<p>如果没有这个<code>差值7</code>的话，一个HashMap不听的插入删除，长度一会7一会8，就会发生频发的转变</p>
</blockquote>
<p>容器中节点分布在hash桶中的频率符合泊松分布，桶的长度超过8的概率非常小，约百万分之1？</p>
<h1 id="七、哈希表如何解决Hash冲突？"><a href="#七、哈希表如何解决Hash冲突？" class="headerlink" title="七、哈希表如何解决Hash冲突？"></a>七、哈希表如何解决Hash冲突？</h1><p><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427152811.png" alt="image-20200427152811036"></p>
<h1 id="八、为什么HashMap使用String、Integer这样的包装类做为key"><a href="#八、为什么HashMap使用String、Integer这样的包装类做为key" class="headerlink" title="八、为什么HashMap使用String、Integer这样的包装类做为key"></a>八、为什么HashMap使用String、Integer这样的包装类做为key</h1><p><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427152956.png" alt="image-20200427152956728"></p>
<h1 id="九、如果key为Object类型，需要如何处理"><a href="#九、如果key为Object类型，需要如何处理" class="headerlink" title="九、如果key为Object类型，需要如何处理?"></a>九、如果key为Object类型，需要如何处理?</h1><p>重写<code>HashCode（）</code>、<code>equals()</code></p>
<p><code>HashCode（）</code></p>
<blockquote>
<p>计算数据的存储位置</p>
<p>实现不恰当，可能会导致严重的hash碰撞</p>
</blockquote>
<p><code>equals()</code></p>
<blockquote>
<p>用于比较是否存在相同key，用于新增或更新</p>
<p>保证键key在哈希表中的唯一性</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/27/kYX3Ac2mc/" data-id="ck9jo09vq000cibfy4hre4z51" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/28/S7UNORYO1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          谈谈ConcurrentHashMap的底层实现，1.7与1.8的详细区别
        
      </div>
    </a>
  
  
    <a href="/2020/04/26/darYNwFgM/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">大厂面试必考：线程池的核心参数、核心流程、5大种类与应用场景</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/">程序员</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/" rel="tag">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmm/" rel="tag">jmm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/jmm/" style="font-size: 10px;">jmm</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 16.67px;">线程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/05/01/%E4%BC%91%E6%81%AF%E4%BC%91%E6%81%AF/">休息休息</a>
          </li>
        
          <li>
            <a href="/2020/04/28/TEST/">TEST</a>
          </li>
        
          <li>
            <a href="/2020/04/28/iX4dA8db2/">ThreadLocal内存泄漏是怎么回事</a>
          </li>
        
          <li>
            <a href="/2020/04/28/S7UNORYO1/">谈谈ConcurrentHashMap的底层实现，1.7与1.8的详细区别</a>
          </li>
        
          <li>
            <a href="/2020/04/27/kYX3Ac2mc/">HashMap底层、1.7与1.8区别、常见面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>