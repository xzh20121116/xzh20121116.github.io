<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>线程的生命周期、6种状态的流转 | 温故知新</title>
<link rel="shortcut icon" href="https://xzh20121116.github.io/favicon.ico?v=1588051013123">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://xzh20121116.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="线程的生命周期、6种状态的流转 | 温故知新 - Atom Feed" href="https://xzh20121116.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="线程的生命周期、6种状态的流转

到底有几种状态
java/lang/Thread.java中 State是个枚举，里面定义了6种状态
线程的6种状态

New（新建）
Runnable（运行）
Blocked（阻塞）
Waitting（无..." />
    <meta name="keywords" content="java,线程" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://xzh20121116.github.io">
  <img class="avatar" src="https://xzh20121116.github.io/images/avatar.png?v=1588051013123" alt="">
  </a>
  <h1 class="site-title">
    温故知新
  </h1>
  <p class="site-description">
    分享也是一种学习
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              线程的生命周期、6种状态的流转
            </h2>
            <div class="post-info">
              <span>
                2020-04-23
              </span>
              <span>
                3 min read
              </span>
              
                <a href="https://xzh20121116.github.io/tag/VadQwd1qw/" class="post-tag">
                  # java
                </a>
              
                <a href="https://xzh20121116.github.io/tag/9tvO-JXYPa/" class="post-tag">
                  # 线程
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>线程的生命周期、6种状态的流转</p>
<!-- more -->
<h1 id="到底有几种状态">到底有几种状态</h1>
<p>java/lang/Thread.java中 State是个枚举，里面定义了6种状态</p>
<h1 id="线程的6种状态">线程的6种状态</h1>
<ul>
<li>New（新建）</li>
<li>Runnable（运行）</li>
<li>Blocked（阻塞）</li>
<li>Waitting（无限期等待）</li>
<li>Timed Watting（限期等待）</li>
<li>Terminated（终止）</li>
</ul>
<h4 id="new新建">New（新建）</h4>
<p>新创建了一个线程对象，但是还没有调用start（）方法</p>
<h4 id="runnable运行">Runnable（运行）</h4>
<p>包含了操作系统线程中的<strong>Ready</strong>（就绪）和<strong>Running</strong>（运行中）</p>
<ul>
<li>
<p><strong>Ready</strong></p>
<p>线程对象创建后，其他线程（比如main线程）调用了该对象的start（）方法</p>
<p>该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权，也就是说有了被cpu运行的资格</p>
</li>
<li>
<p><strong>Running</strong></p>
<p>就ready绪状态的线程在获得cpu时间片后转换为运行中Running</p>
</li>
</ul>
<h4 id="blocked阻塞">Blocked（阻塞）</h4>
<p>在等待着获取一个排它锁（例如：synchronized），这个时间将在另外一个线程放弃这个锁的时候发生</p>
<h4 id="waitting无限期等待">waitting（无限期等待）</h4>
<p>进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断），需要被显示的唤醒，否则就会处于无线等待的状态</p>
<h4 id="timed-waitting限期等待">Timed Waitting（限期等待）</h4>
<p>在达到一定时间之后他们会自动唤醒</p>
<h4 id="终止状态">终止状态</h4>
<p>当线程的run（）方法完成时，或者主线程的main（）方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是他已经不是一个单独执行的线程，线程一旦终止，就不能复生</p>
<h1 id="线程状态的流转">线程状态的流转</h1>
<figure data-type="image" tabindex="1"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200423125835.png" alt="image-20200423125835603" loading="lazy"></figure>
<p>重点掌握运行、阻塞、就绪之间的通信机制</p>
<h4 id="sleep-yield-join-wait">sleep（）、yield（）、join（）、wait（）</h4>
<p><strong>sleep</strong></p>
<blockquote>
<p><strong>Thread</strong>的方法</p>
<p>让出cpu资源，不让锁</p>
<p>当前线程进入阻塞，并释放cpu资源，无优先级、无法被<strong>notify</strong>唤醒</p>
</blockquote>
<p><strong>yield</strong></p>
<blockquote>
<p><strong>Thread</strong>的方法</p>
<p>让出cpu时间，类似sleep，但是无法指定时长，让同优先级的线程有优先执行的机会，调用<strong>yield</strong>只是一个建议：告诉线程调度器，我好了，让相同优先级的线程使用用cpu吧。如果所有正在等待的线程都是低优先级的，则高线程继续执行</p>
</blockquote>
<p><strong>join</strong></p>
<blockquote>
<p><strong>Thread</strong>的方法</p>
<p>不让锁</p>
<p>当前运行的线程调用另一个线程的join方法，等对方执行完之后再执行自己</p>
</blockquote>
<p>wait、notify、notifyall都是obj的方法，必须用在synchronized中</p>
<p><strong>wait</strong></p>
<blockquote>
<p>让出cpu和锁，等待notify唤醒</p>
</blockquote>
<p>wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%88%B0%E5%BA%95%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">到底有几种状态</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81">线程的6种状态</a><br>
*<br>
*<br>
* <a href="#new%E6%96%B0%E5%BB%BA">New（新建）</a><br>
* <a href="#runnable%E8%BF%90%E8%A1%8C">Runnable（运行）</a><br>
* <a href="#blocked%E9%98%BB%E5%A1%9E">Blocked（阻塞）</a><br>
* <a href="#waitting%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85">waitting（无限期等待）</a><br>
* <a href="#timed-waitting%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85">Timed Waitting（限期等待）</a><br>
* <a href="#%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81">终止状态</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%81%E8%BD%AC">线程状态的流转</a><br>
*<br>
*<br>
* <a href="#sleep-yield-join-wait">sleep（）、yield（）、join（）、wait（）</a></li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://xzh20121116.github.io/post/wei-shi-me-shan-liao-shu-ju-biao-de-da-xiao-bu-bian/">
              <h3 class="post-title">
                为什么删了数据，表的大小不变？
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '950ea46256189ac92219',
    clientSecret: '25c6a59041c1d4cd9ac1bd52c32a6b360b070699',
    repo: 'xzh20121116.github.io',
    owner: 'xzh20121116',
    admin: ['xzh20121116'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://github.com/xzh20121116">xzh20121116</a>
  <a class="rss" href="https://xzh20121116.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
