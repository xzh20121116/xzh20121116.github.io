<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    大厂面试必考：线程池的核心参数、核心流程、5大种类与应用场景 | 温故知新
</title>
<link rel="shortcut icon" href="https://xzh20121116.github.io/favicon.ico?v=1587953727914">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://xzh20121116.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://xzh20121116.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-164265712-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-164265712-1');
    </script>
    
        
            
                <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
                

                    
                            
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://xzh20121116.github.io">
                <img class="avatar" src="https://xzh20121116.github.io/images/avatar.png?v=1587953727914" alt="">
            </a>
            <div class="site-title">
                <h1>
                    温故知新
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-detail main-container">
                <!-- left -->
                <div id="content" class="main-container-left">
                    <article class="post i-card">
                        <h2 class="post-title">
                            大厂面试必考：线程池的核心参数、核心流程、5大种类与应用场景
                        </h2>
                        <div class="post-info">
                            <time class="post-time">2020-04-26</time>
                            
                                <a href="https://xzh20121116.github.io/tag/VadQwd1qw/" class="post-tag i-tag
                            i-tag-info">
                            #java
                        </a>
                                
                                <a href="https://xzh20121116.github.io/tag/9tvO-JXYPa/" class="post-tag i-tag
                            i-tag-other_3">
                            #线程
                        </a>
                                
                        </div>
                        
                                <div class="post-content">
                                    <p>大厂面试必考：线程池的核心参数、核心流程、5大种类与应用场景</p>
<!-- more -->
<h1 id="线程池的好处">线程池的好处</h1>
<ol>
<li>
<p>帮助我们管理线程，避免增加创建线程和销毁线程的资源损耗。</p>
<blockquote>
<p>因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的</p>
</blockquote>
</li>
<li>
<p>提高响应速度</p>
<blockquote>
<p>如果任务达到了，直接从线程池拿线程  比 重新创建一个线程，速度快很多</p>
</blockquote>
</li>
<li>
<p>重复利用</p>
<blockquote>
<p>线程用完，再放回池子，可以达到重复利用的效果，节省资源</p>
</blockquote>
</li>
</ol>
<h1 id="线程池的创建">线程池的创建</h1>
<p>juc包下的ThreadPoolExecutor，有序多重载的构造方法，指定不同的构造参数，创建不同类型的线程池。</p>
<pre><code class="language-java">ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;Runnable&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)

</code></pre>
<h1 id="核心参数">核心参数</h1>
<p><strong>corePoolSize</strong></p>
<blockquote>
<p>核心线程数线程池的大小</p>
</blockquote>
<p><strong>maximumPoolSize</strong></p>
<blockquote>
<p>线程池允许创建的最大线程数</p>
</blockquote>
<p><strong>keepAliveTime</strong></p>
<blockquote>
<p>非核心线程的空闲存活时间，一个线程的空闲时间达到这个值，则会终止</p>
</blockquote>
<p><strong>TimeUnit</strong></p>
<blockquote>
<p><strong>keepAliveTime</strong>的时间单位</p>
<p>有7种取值：天、小时、分钟、秒、毫秒、微妙、纳秒</p>
</blockquote>
<p><strong>workQueue</strong></p>
<blockquote>
<p>阻塞队列，当核心线程都被占用时，新来的线程会进入阻塞队列等待执行，如果阻塞队列满了， 会创建工作线程(不超过最大线程数)</p>
</blockquote>
<p><strong>threadFactory</strong></p>
<blockquote>
<p>表示线程工厂。用来生产一组相同任务的线程，线程池的命名是通过这个factory增加组名前缀来实现的。在虚拟机栈分析时，就可以知道线程任务是由哪个线程工厂生产的</p>
</blockquote>
<p><strong>handler</strong></p>
<blockquote>
<p>拒绝策略：当提交任务超过最大线程数时，执行拒绝策略</p>
<ol>
<li><code>AbortPolicy</code>（默认）：丢弃任务并抛出异常</li>
<li><code>DiscardPolicy</code>：丢弃任务，不抛出异常</li>
<li><code>DiscardOldestPolicy</code>：抛弃队列中等待最久的任务，然后把当前任务加入队列</li>
<li><code>callerRunsPolicy</code>：调用人的run方法，绕过线程池直接执行</li>
</ol>
</blockquote>
<h1 id="核心流程">核心流程</h1>
<p>对应<code>execute（）</code>方法</p>
<figure data-type="image" tabindex="1"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200426160957.png" alt="image-20200426160957865" loading="lazy"></figure>
<h1 id="关闭方法">关闭方法</h1>
<p>关闭线程池，有两种方法，可以通过<code>shutdown</code>和<code>shutdownNow</code>这两个方法，原理都是遍历线程池中的所有线程，依次中断。</p>
<p>不同点：</p>
<p><code>shutdown</code></p>
<blockquote>
<p>只是将线程池的状态设置为<code>SHUTDOWN</code>状态，然后中断所有没有正在执行任务的线程</p>
</blockquote>
<p><code>shutdownNow</code></p>
<blockquote>
<p>首先将线程池的状态设置为<code>STOP</code>，然后尝试停止所有正在执行和未执行任务的线程，并返回等待执行任务的列表</p>
</blockquote>
<h1 id="线程池异常处理">线程池异常处理</h1>
<p>使用线程池处理任务的时候，任务代码可能排除RuntimeException，抛出异常后，线程池可能捕获他，也可能创建一个新的线程来替代异常的线程，我们可能无法感知任务出了异常，因此需要考虑线程池异常情况</p>
<ol>
<li>
<p>try-catch 捕获异常</p>
</li>
<li>
<p>submit执行，Future.get()接收异常</p>
</li>
<li>
<p>重写ThreadPoolExecutor.afterExecute方法，处理传递的异常引用</p>
</li>
<li>
<p>实例化时，传入自己的ThreadFactory，设置Thread.UncaughtExceptionHandler处理未检测的异常</p>
<blockquote>
<p>为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常</p>
</blockquote>
</li>
</ol>
<h1 id="五种类型-区别-适用场景">五种类型、区别、适用场景</h1>
<p>newFixedThreadPool (固定数目线程的线程池)</p>
<p>newCachedThreadPool(可缓存线程的线程池)</p>
<p>newSingleThreadExecutor(单线程的线程池)</p>
<p>newScheduledThreadPool(定时及周期执行的线程池)</p>
<p>newWorkStealingPool（创建一个拥有多个任务队列（以便减少连接数）的线程池。1.8新加的）</p>
<h2 id="newworkstealingpool">newWorkStealingPool</h2>
<p>newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中：</p>
<h2 id="newcachedthreadpool">newCachedThreadPool：</h2>
<ul>
<li>
<p>底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(<code>同步队列</code>)</p>
</li>
<li>
<p>通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p>
</li>
<li>
<p>线程池特点</p>
<blockquote>
<ul>
<li>核心线程数为0</li>
<li>最大线程数为Integer.Max_Value</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60秒</li>
</ul>
<p>如果提交任务的速度大于处理任务的速度，每次提交一个任务，就必然会创建一个新的线程，极端情况下会创建过多的线程，耗尽cpu和内存资源</p>
</blockquote>
</li>
<li>
<p>工作机制</p>
<blockquote>
<figure data-type="image" tabindex="2"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427094652.png" alt="image-20200427094652291" loading="lazy"></figure>
<ol>
<li>提交任务</li>
<li>因为没有核心线程，所以任务直接加到阻塞队列</li>
<li>判断线程是否有空县线程，如果有，就去取出任务执行</li>
<li>如果没有空闲线程，就新建一个线程执行</li>
<li>执行完任务的线程，还可以存活60秒，如果存活期间接到新任务就继续活下去，否则就被销毁</li>
</ol>
</blockquote>
</li>
<li>
<p>使用场景：</p>
<blockquote>
<p>用于并发执行大亮短期的小任务</p>
<p>执行很多短期异步的小程序或者负载较轻的服务器</p>
</blockquote>
</li>
</ul>
<h2 id="newfixedthreadpool">newFixedThreadPool：</h2>
<ul>
<li>
<p>底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() <code>无阻塞队列</code></p>
</li>
<li>
<p>通俗：创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列·)</p>
</li>
<li>
<p>线程池特点：</p>
<blockquote>
<ul>
<li>核心线程数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为<code>无界队列LinkedBlockingQueue</code></li>
</ul>
</blockquote>
</li>
<li>
<p>工作机制：</p>
<blockquote>
<figure data-type="image" tabindex="3"><img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427093211.png" alt="image-20200427093211140" loading="lazy"></figure>
<ol>
<li>提交任务</li>
<li>如果线程数少于核心线程数，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列去任务，继续执行。</li>
</ol>
</blockquote>
</li>
<li>
<p>面试题</p>
<blockquote>
<p>使用无界队列的线程池会导致cpu内存飙升吗</p>
<p>会的，如果线程执行任务时间较长，会导致队列的任务越积越多，导致机器内存使用不听飙升，导致oom</p>
</blockquote>
</li>
<li>
<p>使用场景</p>
<blockquote>
<p>适合于cpu密集型的任务，确保cpu在长期被工作线程使用的情况下，尽可能少的分配线程，即适合执行长期的任务</p>
<p>执行长期的任务，性能好很多</p>
</blockquote>
</li>
</ul>
<h2 id="newsinglethreadexecutor">newSingleThreadExecutor:</h2>
<ul>
<li>
<p>底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() <code>无界阻塞队列</code></p>
</li>
<li>
<p>通俗：创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p>
</li>
<li>
<p>适用：一个任务一个任务执行的场景，<strong>同步执行任务的场景</strong></p>
</li>
<li>
<p>线程池特点：</p>
<blockquote>
<ol>
<li>核心线程数为1</li>
<li>最大线程数为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepalivetime为0</li>
</ol>
</blockquote>
</li>
<li>
<p>工作机制</p>
<blockquote>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427095010.png" alt="image-20200427095010650" style="zoom:50%;" />
<ol>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加入到阻塞队列</li>
<li>当前的唯一线程，从队列取任务，执行完一个，再继续取，一个人（一条线程）夜以继日的干活</li>
</ol>
</blockquote>
</li>
<li>
<p>使用场景</p>
<blockquote>
<p>串行执行任务的场景，一个任务一个任务的执行</p>
</blockquote>
</li>
</ul>
<h2 id="newscheduledthreadpool">NewScheduledThreadPool:</h2>
<ul>
<li>
<p>底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</p>
</li>
<li>
<p>通俗：创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</p>
</li>
<li>
<p>适用：<strong><code>周期性执行任务的场景</code></strong></p>
</li>
<li>
<p>线程池特点</p>
<blockquote>
<ul>
<li>
<p>最大线程数为Integer.MAX_VALUE</p>
</li>
<li>
<p>阻塞队列是DelayedWorkQueue</p>
</li>
<li>
<p>keepAliveTime为0</p>
</li>
<li>
<p>scheduleAtFixedRate() ：按某种速率周期执行</p>
</li>
<li>
<p>scheduleWithFixedDelay()：在某个延迟后执行</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>工作机制</p>
<blockquote>
<ol>
<li>添加一个任务</li>
<li>线程池中的线程中DelayQueue中取任务</li>
<li>线程从DelayQueue中获取time大于等于当前时间是task</li>
<li>执行完后修改这个task的time为下次被执行的时间</li>
<li>把这个task放回DelayQueue队列中</li>
</ol>
</blockquote>
</li>
<li>
<p>使用场景：周期性执行任务的场景，需要限制线程数量的场景</p>
</li>
</ul>
<h1 id="线程池五大状态">线程池五大状态</h1>
<pre><code class="language-java">   //线程池状态
   private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;
   private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;
   private static final int STOP       =  1 &lt;&lt; COUNT_BITS;
   private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;
   private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;

</code></pre>
<p>状态切换图：</p>
<img src="https://picgo-xzh.oss-cn-beijing.aliyuncs.com/picgo20200427100536.png" alt="image-20200427100536715" style="zoom:50%;" />
<h2 id="running">Running</h2>
<ul>
<li>接收新任务</li>
<li>处理阻塞队列中的任务</li>
<li>调用线程池的<code>shutdown()</code>方法，可以切换到<strong>SHUTDOWN</strong>状态</li>
<li>调用线程池的<code>shutdownNow()</code>方法，可以切换到<strong>STOP</strong>状态</li>
</ul>
<h2 id="shutdown">SHUTDOWN</h2>
<ul>
<li>不接收新任务，</li>
<li>处理阻塞队列中的任务</li>
<li>队列为空，并且线程池中执行的任务也为空时，进入<strong>TIDYING</strong>状态</li>
</ul>
<h2 id="stop">STOP</h2>
<ul>
<li>不接受新任务</li>
<li>不处理阻塞队列</li>
<li>中断正在运行的任务</li>
<li>线程池中执行的任务为空是，进入此状态</li>
</ul>
<h2 id="tidying">TIDYING</h2>
<ul>
<li>此时所有的任务都已经运行终止，记录的任务数量为0</li>
<li><code>terminated()</code>执行完毕，进入<strong>TERMINATED</strong>状态</li>
</ul>
<h2 id="terminated">TERMINATED</h2>
<ul>
<li>此时线程池彻底终止</li>
</ul>

                                </div>
                    </article>
                    <!--  -->
                    
                        <div class="next-post">
                            <div class="next">下一篇</div>
                            <a href="https://xzh20121116.github.io/post/VPO1pZnCC/">
                                <h3 class="post-title">
                                    大厂面试必考：聊聊java内存模型、volatile的实现原理
                                </h3>
                            </a>
                        </div>
                        
                            <div id="disqus_thread"></div>
                            <div id="gitalk-container"></div>
                </div>
                <!-- middle -->
                <div class="main-container-middle"></div>
                <!-- right -->
                <div id="sidebar" class="main-container-right">
                    
                        <!-- toc -->
                        
    <div class="toc-card i-card ">
        <div class="toc-title i-card-title">目录</div>
        <div class="toc-content">
            <ul class="markdownIt-TOC">
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84">线程池的好处</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA">线程池的创建</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0">核心参数</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B">核心流程</a></li>
<li><a href="#%E5%85%B3%E9%97%AD%E6%96%B9%E6%B3%95">关闭方法</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">线程池异常处理</a></li>
<li><a href="#%E4%BA%94%E7%A7%8D%E7%B1%BB%E5%9E%8B-%E5%8C%BA%E5%88%AB-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">五种类型、区别、适用场景</a>
<ul>
<li><a href="#newworkstealingpool">newWorkStealingPool</a></li>
<li><a href="#newcachedthreadpool">newCachedThreadPool：</a></li>
<li><a href="#newfixedthreadpool">newFixedThreadPool：</a></li>
<li><a href="#newsinglethreadexecutor">newSingleThreadExecutor:</a></li>
<li><a href="#newscheduledthreadpool">NewScheduledThreadPool:</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81">线程池五大状态</a>
<ul>
<li><a href="#running">Running</a></li>
<li><a href="#shutdown">SHUTDOWN</a></li>
<li><a href="#stop">STOP</a></li>
<li><a href="#tidying">TIDYING</a></li>
<li><a href="#terminated">TERMINATED</a></li>
</ul>
</li>
</ul>

        </div>
        <script>
            function locateCatelogList() {
                /*获取文章目录集合,可通过:header过滤器*/
                var alis = $('.post-content :header');
                /*获取侧边栏目录列表集合**/
                var sidebar_alis = $('.markdownIt-TOC a');
                /*获取滚动条到顶部的距离*/
                var scroll_height = $(window).scrollTop();
                for (var i = 0; i < alis.length; i++) {
                    /*获取锚点集合中的元素分别到顶点的距离*/
                    var a_height = $(alis[i]).offset().top;
                    if (a_height < scroll_height) {
                        /*高亮显示*/
                        sidebar_alis.removeClass('on');
                        $(sidebar_alis[i]).addClass('on');
                    }
                }
            }
            $(function() {
                /*绑定滚动事件 */
                $(window).bind('scroll', locateCatelogList);
            });
        </script>
    </div>
    
                            

                </div>




            </div>


            <div class="site-footer">
  Powered by <a href="https://github.com/xzh20121116">xzh20121116</a> | 
  <a class="rss" href="https://xzh20121116.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>


    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
    
        
            <script>
    window.onload = function() {
        var gitalk = new Gitalk({
            clientID: '950ea46256189ac92219',
            clientSecret: '25c6a59041c1d4cd9ac1bd52c32a6b360b070699',
            repo: 'xzh20121116.github.io',
            owner: 'xzh20121116',
            admin: ['xzh20121116'],
            id: (location.pathname).substring(0, 49), // Ensure uniqueness and length less than 50
            distractionFreeMode: false // Facebook-like distraction free mode
        })

        gitalk.render('gitalk-container')
    }
</script>
                

                    
                                
</body>

</html>