<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    温故知新
</title>
<link rel="shortcut icon" href="https://xzh20121116.github.io/favicon.ico?v=1587521406421">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://xzh20121116.github.io/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://xzh20121116.github.io/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-164265712-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'UA-164265712-1');
    </script>
    
</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://xzh20121116.github.io">
                <img class="avatar" src="https://xzh20121116.github.io/images/avatar.png?v=1587521406421" alt="">
            </a>
            <div class="site-title">
                <h1>
                    温故知新
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://xzh20121116.github.io/post/mysql-zhi-suo/">
                        mysql之锁
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-21</time>
                    
                        <a href="https://xzh20121116.github.io/tag/gOINufb6v/" class="post-tag i-tag
                            i-tag-other_2">
            #mysql
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            表级锁
mysql 里面表级别的锁有两种：表锁、元数据锁（meta data lock ，MDL）
表锁

表锁的语法是 lock tables ... read/write。与 FTWRL类似，可以用 unlock tables主动释放锁，也可以在客户端断开连接的时候自动释放。需要注意：lock tables 语法除了会限制其他的线程的读写之外，也限定了本线程接下来的操作对象
举个例子：
线程A中执行 lock tables  t1 read，t2 write  这个语句，则其他线程写 t1 ，读t2 的语句都会被阻塞。线程A 在释放锁之前，也只能 执行读 t1、写t2的操作。连写t1都不允许，自然也不能访问其他表
对于innodb来说，一般不使用lock tables命令，影响太大

MDL

mdl不需要显式使用，在访问一个表的时候会自动加上。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
因此，在 MySQL 5.5 版本中引入了 MDL，
MDL 读锁：对一个表做增删改查操作，自动加
MDL 写锁：对表做结构变更操作的时候，自动加

读锁之间不互斥，即：多个线程可以同时对一张表增删改查
读写之间互斥、写锁之间互斥：保证变更表结构操作的安全性。因此如果有两个线程要同事给一个表加字段，需要一个等待另一个执行完才能开始

mdl的作用：保证读写的正确性

行级锁
mysql的行锁是引擎层各自实现的，但并不是所有的引擎都支持行锁，MyIsam不支持行锁。

事务a更新1行数据，事务b也更新同一行数据，那么B要等A执行完之后，才能进行更新

两阶段锁
在innodb中，行锁是在需要的时候才加上的，但并不是不用了就立刻释放，而是等待事务结束了才释放（commit提交后事务结束）。
如果事务中需要锁多行，要把可能造成锁冲突，最可能影响并发度的锁尽量往后放
死锁



时间点
事务a
事务b




t1
begin; set k=xx where id =1
begin;


t2

set k =yy where id=2


t3
set k =yy where id=2



t4

set k=xx where id =1



这个时候，事务A在等待事务B释放 id =2的行锁，而事务B在等待事务A释放id =1 的行锁，互相等待对方释放锁资源，即进入死锁状态
MVCC
mysql中，实际上每条记录在更新的时候都会同步记录一条回滚操作，通过回滚操作都可以得到前一个状态的值。
假如一个值1被按顺序修改为2、3、4，在回滚日志里就会有类似下面的记录

当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view，在视图A、B、C里面记录的分别是1、2、4
同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制——MVCC

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://xzh20121116.github.io/post/mysql-zhi-suo/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://xzh20121116.github.io/post/we/">
                        面试准备
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-21</time>
                    
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            
全部使用长连接，可能会导致mysql占用内存涨得特别快？
因为mysql在执行过程中临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候才释放，如果长连接累计下来，导致内存占用太大，被系统强行杀掉（oom），从现象看就是mysql异常重启了
如何解决呢？
两种方案：

定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

redo log（重做日志：是innodb特有的日志）
特点： 记录的是数据修改之后的值，不管事务是否提交都会记录下来
用于保证crash-safe（防撞）能力，

innodb_flush_log_at_trx_commit参数设置成1，表示每次事务的redo log 都直接持久化到磁盘，建议设置成1，保证重启后数据不丢失
sync_binlog 设置为1，表示每次事务的binlog都持久化到磁盘，保证重启后binlog不丢失

WAL技术，全称 WRITE-AHEAD logging
它的关键点就是先写日志，再写磁盘
当有一条记录要更新的时候，innodb引擎就会先把记录写到 redolog，并更新内存，这个时候更新就算完成了。
InnoDb会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打样以后掌柜做的事
有了redolog，innodb就可以保证技术数据库发生异常重启，之前提交的记录都不会丢失，这就是crash-safe
bin log（归档日志：server层自己的日志，所有引擎都可以使用
binlog有两种模式

statement格式记录的是sql语句
row格式（一般采用这个）：记录行的内容，记录两行，更新前，更新后都有

redolog与binglog区别

redolog是innodb引擎特有的，只能innodb用；
binlog是mysql的server层实现的，所有引擎都可以用
redolog 是物理日志，记录的是“在某个数据页上做了什么修改”
binlog是逻辑日志，记录的是“语句的原始逻辑：给id = 2 的这一行的c字段加1”
redoglog是循环写的，空间固定会用完，binlog是可以追加下入的，当binlog文件写到一定大小的时候，会自动切换下一个，并不会覆盖以前的日志

备份恢复
以binlog为基础，通过它记录的完整逻辑操作，备份出一个和源库一样的数据
事务
事务的特性：
原子性、一致性、隔离性、持久性
多事务同事执行的时候，可能会出现的问题：


脏读()

当数据库中一个事务A正在修改一个数据但是还未提交或者回滚，
另一个事务B 来读取了修改后的内容并且使用了，
之后事务A提交了，此时就引起了脏读。
此情况仅会发生在： 读未提交.



不可重复读

在一个事务A中多次操作数据，在事务操作过程中(未最终提交)，
事务B也才做了处理，并且该值发生了改变，这时候就会导致A在事务操作
的时候，发现数据与第一次不一样了。 就是不可重复读。
此情况仅会发生在：读未提交、读已提交



幻读

一个事务按相同的查询条件重新读取以前检索过的数据，
却发现其他事务插入了满足其查询条件的新数据，这种现象就称为幻读。
幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.
一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。
此情况会回发生在：读未提交、读提交、可重复读的隔离级别.



事务的隔离级别


读未提交（脏读、不可重复读、幻读）

一个事务还未提交，它所做的变更就可以被别的事务看到



读已提交（不可重复读、幻读）

一个事务提交之后，它所做的变更才可以被别的事务看到



可重复读（mysql默认、幻读）

一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的



串行化

对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行



创建视图的时机
实际上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准
可重复读：在事务启动时创建视图，整个事务存在其都用这个视图
**读已提交：**这个视图是sql语句开始执行的时候创建的
**读未提交：**没有视图的概念，直接返回记录上的最新值
串行化：直接加锁的方式来避免并行访问
什么是视图

view，用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果，创建视图的语法是 create view，查询方法与表一样
InnoDB在实现MVCC时用到的一致性读视图，即： consistent read view，用以支持 读已提交、可重复读 的实现

mvcc的实现逻辑
不同时刻启动的事务会有不同的 read-view，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制

一个值被按顺序 从 1 修改为 2、3、4，对于read-view a，要得到1，就必须将当前值依次执行图中的所有回滚操作得到


快照在mvcc里是怎么工作的
对于可重复读：事务启动的时候就“拍了个快照”，注意，这个快照是基于整库的。
这个时候，你可能会说了，如果一个库100g，那么我起一个事务，mysql就要拷贝100g啊
实际上，并不需要拷贝这100g
InnoDB里面每个事务都有一个唯一事务id，叫 transaction id，它是事务开始的时候向InnoDb的事务系统申请的， 按申请顺序递增的。
而每行的数据都是有多个版本的，每次事务更新数据的时候，都会生成一个新的数据版本，并且把 事务id 赋值给这个数据版本的事务id，记为 row trx_id，旧的数据版本也要保留，并且在新的数据版本中，能够有信息可以直接拿到它。
也就是说，数据表中的一行记录，可能有多个版本，每个版本都有自己的row_trx_id。
语句更新会生成 undo log 回滚日志，每个版本并不是物理上真实存在的，而是当需要的时候根据当前版本和 undo log 计算出来的
按照 可重复读的定义一个事务启动的时候，能够看到所有已经提交的事务，但是之后，这个事务执行期间，其他事务的更新对它不可见。
在实现上，InnoDb为每个事务构造了一个数组，用来保存这个事务启动瞬间，当时正在“活跃”的所有事务id，活跃是指，启动了但是没有提交
数组里面事务id的最小值为低水位，当前系统里面已经创建国的事务id的最大值+1为高水位
这个视图数组和高水位，就组成了当前事务的一致性视图 read-view
而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的
配置隔离界别的方法
启动参数transaction-isolation
事务隔离的实现
每条记录在更新的时候都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本， 这就是数据库的多版本并发控制（MVCC）
回滚日志什么时候删除？
系统判断没有事务需要用到这些回滚日志的时候，回滚日志就会被删除
什么时候不需要了？
当系统里没有比这个回滚日志更早的read-view的时候
为什么不使用长事务
长事务意味着系统里存在很多很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间
长事务占用锁资源，可能会拖垮库
如何避免长事务对业务的影响

开发时，尽量减小事务范围
如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长，监控Inndb_trx表（查询事务时间），发现长事务报警

首先，从应用开发端来看：

确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个 select 语句放到了事务中。这种只读事务可以去掉。
业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。（为什么会意外？在后续的文章中会提到这类案例）

其次，从数据库端来看：

监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；
Percona 的 pt-kill 这个工具不错，推荐使用；
在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；
如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，这样设置后清理起来更方便。

索引
主键索引查询
如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
普通索引查询
如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。
也就是说非主键索引的查询需要多扫描一棵索引树，因此应尽量使用主键查询
什么是回表
通过普通索引无法一次获取到查询结果，需要根据普通索引找到的主键索引，再从主键索引获取所需数据的过程叫回表
索引维护
使用自增主键的插入，符合递增插入，每次插入都是一条新纪录，都是追加操作，不涉及挪动其他记录，也不会触发叶子节点的分裂
从存储空间考虑

比如说有一个身份证，还有一个自增id，用哪个做主键呢？
由于每个非主键索引的叶子节点存储都是主键的值，如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，如果用整型做主键，则只需要4个字节，如果是长整型（bigint）则是8个字节

显然：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小
为什么使用b+树做索引
能够很好的配合磁盘读写的特性，减少单词查询的磁盘访问次
最左前缀
联合索引（a,b）, 一般不需要单例的在a上建立索引了

如果可以通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的

比如（身份证号，姓名）这个高频请求建立联合索引
如果查询条件里只有 b 字段是无法使用(a,b)这个联合索引的
此时是否需要维护额外的b索引呢？这个时候需要考虑空间了

比如说（name，age‘），name 字段比age字段大，name建议建立一个（name，age的联合索引和一个age的单独索引）

索引下推
select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;

查找出名字的第一个字“张”，且年龄是10岁的所有男孩
根据(name,age)索引，开始查找

在mysql5.6之前，只能从id3开始一个个回表，到主键索引上找出数据行，在对比字段值
5.6版本引入了 索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数


上面是无索引下推执行流程

每一个虚线箭头表示回表一次。
在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。


上面索引下推执行流程

InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。

锁
mysql里面的锁根据加锁范围分为三类：全局锁、表级锁、行锁
全局锁


使用场景：做全局逻辑备份，也就是把整库每个表都select出来存成文本

MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

缺点


如果在主库上备份，那么备份期间都不能执行更新，业务基本停摆


从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟


不加锁的话，备份系统备份得到的库不是一个逻辑时间点，这个视图是逻辑不一致的


如何获得一致性视图

在可重复读的隔离界别下开启一个事务
官方自带的逻辑备份工具是mysqldump，使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，由于mvcc的支持，这个过程中数据是可以正常更新的



对于全部是innodb引擎的库，建议使用single-transaction参数


问题来了，有了这个功能，为什么还需要FTWRL（全局只读）呢？

因为：有的引擎是不支持这个隔离界别的，比如mylsam不支持事务的引擎，如果备份过程中有更新，总是能取到最新的数据，那么就破坏了数据一致性，这个时候就用到FTWRL



既然全库只读，为什么不使用 set global readOnly=true 的方式呢？

这个方式也可以放全库进入只读状态，但是还是建议使用FTWRL

有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库，因此，修改global变量的方式影响面更大，不建议使用
异常处理机制上的差距，执行FTWRL命令之后，客户端发生异常断开，那么mysql会自动释放这个全局锁
而设置成readonly之后，如果客户端发生异常，则数据库一致保持readonly状态，风险高




表锁
mysql中的表锁有两种，一种是元数据锁（meta data lock，mdl），一种是表锁

表锁的语法是 lock tables … read/write。


与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。
在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。


另一类表级的锁是 MDL（metadata lock)。


MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。
事务中mdl锁，在语句执行开始时申请，但是语句结束后并不会立马释放，而是等整个事务提交后再释放
如何安全的给小表加字段

首先处理长事务，因为事务不提交，就会一直占用mdl锁，先查询出长事务，暂停执行变更操作，或者kill掉长事务，但是如果是热点表，请求很频繁呢，kill就不管用了
在alter table语句里面设定等待时间，如果在指定的等待时间里面能够拿到mdl写锁最好，拿不到也不要阻塞后面的业务语句，之后由dba重试命令来执行

两阶段锁协议
在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放，这就是两阶段锁协议

知道了这个设定，的帮助是：如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后放

死锁
原始的两种策略

直接进入等待，直到超时，超时的时间可以通过参数 innodb_lock_wait_timeout来设置，默认是50s
发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行，将 innodb_deadlock_detect 设置为 on，表示开启这个逻辑

正常情况推荐使用第二种策略，即：主动死锁检测；
但是如果有1000个并发线程要同事更新一行，那么死锁检测操作就是100万这个量级了，虽然最终检测的结果是没有死锁，但是这期间要消耗大量的cpu资源，结果：cpu利用率很高，但是每秒却执行不了几个事务
真实的两种策略

可以死锁检测临时关掉，危险：意味着出现大量的超时
控制并发度：基本思路：对于相同行的更新，在进入引擎前排队 ，这样innodb内部就不会有大量的死锁检测工作了

删除表里面的前10000行数据，选择哪一种


直接 delete from t limit 10000;

单个语句占用时间长，锁的时间比较长，大事务会导致主从延迟



在一个连接内循环执行20次 delete from t limit 500；

相对较好



在20 个连接中同时执行delete from t limit 500；

会人为造成锁冲突



要区分行锁、mdl锁、表锁的区别，对于InnoDb更新一行，可能过了mdl关，却被挡在行锁阶段
索引
普通索引  、 唯一索引 ，如何选择？
查询性能上是没太大区别的，主要考虑的是更新性能的影响，尽量使用普通索引
普通索引：会将变更操作缓存到changbuffer中，在下一次读的时候才会进行一个merge操作，更新磁盘中

日志系统，账单系统，写多读少

如果使用的是机械硬盘，change buffer这个机器的效果是非常显著的，
change buffer 与 redo log
redo log：先写日志，再写磁盘，也是尽量减少随机读写

举个例子，要往 一个表里插入两条书库，k1，k2；
insert into t(id,k) values(id1,k1),(id2,k2);

k1所在的数据页（page1）在内存（innodb buffer pool ）中，k2所在的数据页（page2）不在内存中

page1在内存中，直接更新内存
page2不在内存中，往 内存的change buffer 区域，记录一条：“我要往page2 插入一行 ”的信息
将1、2两个动作记入到 redo log 中

至此，事务就完成， 执行这两个更新的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作盒合在一起写了一次磁盘）
现在执行读操作
select * from t where k in (k1, k2)



读page1的时候，直接从内存返回。（此时还没有写磁盘，wal之后如果读数据，不一定读盘）


读page2的时候，需要把page2从磁盘读入内存中，然后应用change buffer里的操作日志，生成一个正确的版本并返回结果
可以看到，读page2的时候，这个数据页才会被读入内存



简单的对比这个两个机制：

redolog：主要节省的是随机写磁盘的 io消耗（转成顺序写）
change buffer：主要节省的则是随机读磁盘的 io消耗

mysql为什么会选错索引？
选择索引是优化器的逻辑
扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的cpu资源越少
当然扫描行并不是唯一的判断标准，优化器还会结合是否使用临时表，是否排序等因素进行综合判断
有时候回表也肯能导致盘算执行行数出错

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://xzh20121116.github.io/post/we/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://xzh20121116.github.io/post/hello-gridea/">
                        Hello Gridea
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2018-12-12</time>
                    
                        <a href="https://xzh20121116.github.io/tag/j-wXpbjuw/" class="post-tag i-tag
                            i-tag-">
            #Gridea
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                    <div class="post-content-abstract">
                                        <p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>

                                    </div>
                                    
                                            <a class="btn btn-text" href="https://xzh20121116.github.io/post/hello-gridea/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://xzh20121116.github.io/images/avatar.png?v=1587521406421)">
        </div>
        <h1 class="id_card-title">
            温故知新
        </h1>
        <h2 class="id_card-description">
            温故而知新
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/xzh20121116">xzh20121116</a> | 
  <a class="rss" href="https://xzh20121116.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>